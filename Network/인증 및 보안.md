> **📄 목차** <br>
> 1. 인증과 인가 
> 2. 쿠키 vs 세션
> 3. JWT란?


<br>


# 1. 인증과 인가

### 📌 인증(Authentication) - "누구인가?"
인증은 클라이언트가 주장하는 신원을 확인하는 과정을 의미합니다.
- 인증 예시
    - 사용자 ID 및 비밀번호
    - OAuth
    - API Key
    - Token

<br>

### 📌 인가(Authorization) - "무엇을 할 수 있는가?"
인가는 해당 클라이언트가 인증이 되었다는 가정하에 진행되는 절차 과정입니다. 인증된 사용자가 어떠한 리소스에 접근할 수 있는지 권한여부 등을 결정하는 과정입니다.

<br>

### ❓ 인증과 인가 절차를 두어야 하는 이유
1. 시스템 보안 유지
2. 권한 관리
3. 사용자 맞춤화 경험 제공

<br>
<hr>

# 2. 쿠키 vs 세션
### 💡 HTTP 프로토콜의 특징

**비연결성(Connectionless)**
- 클라이언트가 서버에 요청(Request)을 보내고 서버가 응답(Response)하면 연결이 종료됩니다. HTTP 1.1 버전부터는 `keep-alive` 헤더를 통해 연결을 유지할 수 있습니다.

**무상태성(Stateless)**
- 클라이언트와 서버 간의 요청과 응답이 완료되면 상태 정보를 유지하지 않습니다. 이로 인해 동일 사용자의 요청임을 인식하지 못합니다.

<br>

### 🔧 쿠키와 세션이 필요한 이유
HTTP의 비연결성 및 무상태성 특성으로 인해, 웹 애플리케이션에서는 사용자가 로그인을 한 후에도 상태를 유지해야 할 필요가 있습니다. 이를 위해 사용되는 기술이 바로 쿠키와 세션입니다.

<br>

## 2.1 🍪 쿠키(Cookie)란?
쿠키는 웹 서버가 사용자의 웹 브라우저에 저장하는 작은 데이터 파일로, 사용자가 동일 웹 사이트를 방문할 때 상태를 기억하는 데 사용됩니다.

<br>

### ✅ 쿠키의 특징
- `key-value`쌍으로 구성되어 있는 데이터 파일
- 쿠키이름, 쿠키값, 만료시간, 전송할 도메인명, 전송할 경로, 보안연결여부, HttpOnly여부로 구성
- 한 쿠키당 4KB(= 4096 byte)까지 저장가능하며, 도메인당 20개의 쿠키를 가질 수 있음
- 기본적으로 쿠키는 웹 브라우저가 종료되면 삭제됨

<br>

### 🍪 쿠키의 사용 목적
1. 세션 관리(Session Management)
    - 로그인 상태 유지, 장바구니 정보 저장
2. 개인화(Personalization)
    - 사용자 설정 저장 (예: 테마, 언어)
3. 트래킹(Tracking)
    - 사용자 행동 추적 (예: 광고 클릭 수)

<br>

### 🍪 쿠키의 종류
| 종류 | 특징  |
|---|---|
| Session Cookie	| 일반적으로 만료시간(Expire Date)를 설정하고 메모리에만 저장되며, 브라우저 종료 시 쿠키를 삭제 |
| Persistent Cookie	 | 장기간 유지되는 쿠키이다. 파일로 저장되어 브라우저 종료와 관계없이 사용 |
| Secure Cookie | HTTPS 프로토콜에서만 사용하며, 쿠키 정보가 암호화되어 전송 |
| Third-Party Cookie | 방문한 도메인과 다른 도메인의 쿠키이다. 일반적으로 광고 배너 등을 관리할 때 유입 경로를 추적하기 위해 사용한 |

<br>

### ⚙️ 쿠키의 작동 방식
<img width="593" alt="스크린샷 2025-06-29 오후 10 04 16" src="https://github.com/user-attachments/assets/3a775df0-c869-4e27-94df-6a52ec1e4684" />

1. 클라이언트가 서버로 HTTP 요청을 보냄
2. 요청 받은 서버에서 쿠키를 HTTP 헤더(Set-Cookie)에 담아서 응답을 보내고, 클라이언트는 받은 쿠키를 도메인 서버 이름으로 정렬된 디렉토리에 저장
3. 이후 클라이언트가 동일한 서버로 요청을 보내면 자동으로 요청 헤더에 저장된 쿠키를 함께 전송
4. 만약 변경된 내용이 있다면 응답시 함께 업데이트된 쿠키를 전달


<br>

### ⚠️ 쿠키의 단점
클라이언트에서 쉽게 조작 가능하여 민감 정보 저장에 적합하지 않음


<hr>

## 2.2 🗝️ 세션(Session)이란?
세션은 서버 측에 저장되는 사용자 상태 정보를 관리하는 기술로, 클라이언트는 세션 ID를 통해 서버에서 자신의 상태를 확인합니다. 브라우저가 종료되기 전까지 클라이언트의 요청을 유지하게 해줍니다.

<br>

### ✅ 세션의 특징
- 웹 서버에 웹 컨테이너의 상태를 유지하기 위한 정보를 저장
- 웹 서버에 저장되는 쿠키(session cookie)
- 브라우저를 닫거나, 서버에서 세션을 삭제했을 때만 삭제가 되므로, 쿠키보다 비교적 보안이 좋음
- 각 클라이언트에 고유 Session ID를 부여한다. Session ID로 클라이언트를 구분해 각 요구에 맞는 서비스를 제공


<br>

### 🗂️ 세션의 사용 목적
사용자나 다른 누군가에게 노출되면 안되는 보안적으로 중요한 정보들을 서버 안에서 다루기 위해 사용합니다.

<br>

### ⚙️ 세션의 작동 방식
<img width="607" alt="스크린샷 2025-06-29 오후 10 03 58" src="https://github.com/user-attachments/assets/f816f303-9600-47a7-9bbf-5f6d7b0664cd" />

1. 클라이언트가 서버로 HTTP 요청을 보냄(세션 ID ❌)
2. 세션 ID가 존재하지 않는다면 서버는 세션 ID를 생성해 클라이언트에게 전달하고, 클라이언트는 해당 세션 ID를 쿠키에 저장
3. 클라이언트가 서버로 HTTP 재요청을 보냄(세션 쿠키 포함)
4. 서버는 요청 헤더의 세션 ID가 유효한지 검증 후 요청 처리 후 응답


<br>

### ⚠️ 세션의 단점
- 세션의 내용은 서버에 저장되기 때문에 계속하여 늘어날 경우 서버에 부하 발생 가능성
- 세션에 대한 정보가 서버에 있어 쿠키에 비해 비교적 속도가 느림

<br>


### 📊 쿠키와 세션의 차이점
|      | Cookie | Session |
|---|---|---|
| 저장 위치 | Client | Server |
| 저장 형식 | Text | Object |
| 만료 시점 | 쿠키 저장 시 설정(설정 없으면 브라우저 종료 시) | 정확한 시점 모름 |
| 리소스 | 클라이언트의 리소스 | 서버의 리소스 |
| 용량 제한 | 한 도메인 당 20개, 한 쿠키 당 4KB | 제한 없음 |
| 속도 | 쿠키에 정보가 있어 비교적 빠름 | 정보가 서버에 있어 비교적 느림 |

<br>
<hr>

# 3. JWT(Json Web Token)란?

### 🔥 JWT 등장배경
기존의 세션 기반 인증 방식에서는 다음과 같은 문제점이 있었습니다:
- 서버에 세션 정보를 저장하고 관리해야 하므로 서버 부하 증가
- 서버 확장 시 세션 데이터를 공유해야 하는 스케일링 문제
- 세션 저장소에 문제가 발생하면 인증 체계가 무너져 전체 인증 불가 상태 발생

이를 해결하기 위해 등장한 것이 JWT입니다. JWT는 서버에서 상태를 저장하지 않고도 클라이언트를 인증할 수 있어, stateless 애플리케이션 구현이 가능합니다. 특히 HTTP의 Connectionless을 극복하고 서버 확장성 문제를 해결할 수 있습니다.

<br>

### 🔍 JWT란?
JWT(Json Web Token)는 JSON 객체를 사용하여 정보 또는 클레임을 안전하게 전송하기 위한 토큰 기반 인증 표준입니다. 주로 사용자 인증 및 권한 부여를 위해 많이 사용되며, 클라이언트와 서버 간의 stateless 방식으로 데이터를 주고받을 때 활용됩니다.

<br>

### 🧩 JWT의 구조
JWT는 다음과 같은 세 가지 부분으로 구성됩니다.

1. **Header**
    - 토큰의 유형과 서명에 사용할 알고리즘 정보를 담고 있습니다.
    ``` java
    {
        "typ": "JWT",
        "alg": "HS256"
    }
    
   ```

    - 필드 설명
        - typ: 토큰 유형 (JWT)
        - alg: 서명 시 사용하는 암호화 알고리즘 (예: HS256)

<br>

2. **Payload**
    - 토큰에 포함할 실제 데이터(클레임)를 담고 있습니다. 주로 사용자 정보나 토큰 만료 시간 등이 포함됩니다.
   ``` java
   {
       "sub": "JWT",
       "iss": "ori",
       "exp": 1636989718,
       "typ": 1636987918
   }
   ```
    - 표준 스팩
        - `iss` (Issuer): 토큰 발급자
        - `sub` (Subject): 토큰 제목
        - `aud` (Audience): 토큰 대상자
        - `exp` (Expiration Time): 토큰 만료 시간
        - `nbf` (Not Before): 토큰 활성 날짜
        - `iat` (Issued At): 토큰 발급 시간
        - `jti` (JWT ID): JWT 토큰 식별자

<br>

3. **Signature**
    - 헤더와 페이로드를 조합하여 해싱하고 비밀 키로 서명한 부분입니다.
    - 이 서명을 통해 JWT가 변조되지 않았음을 확인할 수 있습니다.
   ``` java
   HMACSHA256(
        base64UrlEncode(header) + "." +
        base64UrlEncode(payload),
        secret
   )
   ```


아래처럼 각각의 구성 요소가 점(.)으로 구분되어 있습니다.
```
Header.Payload.Signature
```

<br>

### ✅ JWT 장점
- 무상태성: 서버에 사용자 상태를 저장하지 않아도 됨
- 확장성: 분산 서버 환경에서 유리
- 보안성: 서명을 통해 데이터 변조 방지
- 범용성: 다양한 플랫폼에서 사용 가능

<br>



### ⚙️ JWT 동작 방식(로그인)
※ Access Token + Refresh Token 활용시 흐름 <br>
<img width="609" alt="스크린샷 2025-06-29 오후 10 04 33" src="https://github.com/user-attachments/assets/101a7fc3-c446-4358-8a44-c96ea95996b3" />


1. 사용자가 로그인 요청(ID&PW)을 보냅니다.
2. 서버는 유효성을 검증하여 JWT를 발급합니다.
    - 토큰에는 사용자 ID, 권한, 만료 시간 등 다양한 정보가 포함될 수 있음
3. 클라이언트는 API 요청시 발급받은 JWT를 헤더에 포함하여 전송합니다.
4. 서버는 토큰에 포함된 서명을 검증 후, 클라이언트로 응답을 전송합니다.


[CASE: 토큰 만료]

1. Refresh Token을 헤더에 담아 Access Token 발급 요청
2. Refresh Token에 문제가 없다면 Access Token 재발급

<br>

### ⚙️ 검증 방식
1. **해더 검증**
    - 변환된 JSON 객체에서 알고리즘 및 토큰 종류를 확인합니다. 알고리즘은 서버에 지정된 알고리즘과 일치해야 합니다.
2. **페이로드 검증**
    - 변환된 JSON 객체에서 발급 시간, 만료 시간, 사용자 정보 등을 확인합니다. 만료 시간이 현재 시간보다 이전이면 토큰이 만료된 것으로 간주됩니다.
    - 사용자 정보는 서버에 저장된 사용자 정보와 일치해야 합니다.
3. **시그니처 검증**
    - 헤더에서 확인한 알고리즘을 사용하여 서버의 비밀 키와 페이로드를 기반으로 새로운 서명을 생성합니다. 생성된 새로운 서명과 클라이언트에게 받은 토큰의 서명을 비교합니다.
    - 두 시그니처가 일치해야 유효성 검증이 이루어집니다.

<br>


### ⚠️ JWT 단점
- 기밀성 문제: 페이로드는 인코딩된 상태로 전송되므로 암호화되지 않음
- 토큰 탈취 문제: 유출 시 만료 시간 전까지 사용 가능
- 토큰 크기: 데이터가 많아질수록 토큰 길이 증가
- 만료 시간 관리 어려움: 만료 전까지 무효화 불가능

<br>

### 📝 보완책
토근 탈취 위험을 완화하기 위해, **토큰 만료시간을 짧게 설정**해야 한다!


짧은 JWT 유효시간을 보완하는 방법
1. Sliding Session
2. Refresh Token


### Sliding Session
- 특정한 서비스를 계속 사용하고 있는 특정 유저에 대해 만료 시간을 연장시켜주는 방법입니다.
- 다만, 접속이 단발성으로 일어난다면 Sliding Session으로 연장시켜줄 수 없는 상황이 생기고, 너무 긴 Access Token을 발급시켜준 상황이라면 Sliding Session 때문에 무한정 사용하는 상황이 발생할 수 있습니다.

<br>

### Refresh Token
- 가장 많이 사용하는 방법으로 JWT를 처음 발급할 때 Access Token과 함께 Refresh Token 이라는 토큰을 발급하여 짧은 만료시간을 해결하는 방법입니다.
- 만약 클라이언트가 AccessToken이 만료됨을 본인이 인지하거나, 서버로부터 만료됨을 확인받았다면 Refresh Token으로 서버에게 새로운 AccessToken을 발급하도록 요청하여 발급받는 방식입니다.

<br><br>

> 🔗 참고 <br>
> https://velog.io/@octo__/%EC%BF%A0%ED%82%A4Cookie-%EC%84%B8%EC%85%98Session <br>
> https://whitehartlane.tistory.com/56 <br>
> https://infinitecode.tistory.com/74
