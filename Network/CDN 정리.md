# CDN (Content Delivery Network) - 컴퓨터 네트워크 관점

CDN은 분산 시스템과 네트워크 아키텍처의 핵심 개념으로, 지리적으로 분산된 서버들을 통해 콘텐츠를 효율적으로 전달하는 네트워크 인프라입니다. 즉 컨텐츠의 병목 현상을 없애준다.

### 동작원리

CDN은 원본 서버(Origin Server)의 콘텐츠를 전 세계 여러 지역의 엣지 서버(Edge Server)에 복사하여 저장합니다. 사용자가 웹사이트에 접속하면, 가장 가까운 엣지 서버에서 콘텐츠를 제공받게 됩니다.

## CDN의 네트워크 아키텍처

### 1. 계층적 구조

```
Origin Server (원본 서버)
    ↓
Regional Cache (지역 캐시)
    ↓
Edge Cache (엣지 캐시)
    ↓
End User (최종 사용자)
```

### 2. 주요 구성 요소

**Origin Server (원본 서버)**

- 모든 콘텐츠의 원본이 저장된 서버
- 캐시 미스 발생 시 최종적으로 요청되는 서버
- 일반적으로 단일 데이터센터에 위치

**Edge Server (엣지 서버)**

- 사용자와 가장 가까운 위치의 캐시 서버
- 전 세계 주요 도시에 분산 배치
- 가장 빈번하게 요청되는 콘텐츠를 캐싱

**Regional Cache (지역 캐시)**

- 엣지 서버와 원본 서버 사이의 중간 캐시
- 여러 엣지 서버가 공유하는 상위 캐시
- 캐시 계층 구조에서 중간 역할

## CDN의 핵심 네트워크 원리

### 1. DNS 기반 라우팅

#### DNS 해석

```
사용자: cdn.example.com 요청
    ↓
로컬 DNS 서버: CDN DNS 서버에 쿼리
    ↓
CDN DNS 서버:
- 사용자 IP 주소 분석
- 지리적 위치 확인
- 네트워크 토폴로지 고려
- 서버 부하 상태 확인
    ↓
최적 엣지 서버 IP 반환 (예: 203.241.132.1)
```

#### 요청 라우팅

```
사용자 → 엣지 서버 연결
- TCP 3-way handshake
- SSL/TLS 협상 (HTTPS인 경우)
- HTTP 요청 전송
```

#### 캐시 히트/ 미스

```
사용자 요청: GET /images/logo.png
    ↓
엣지 서버 캐시 테이블 확인:
Key: /images/logo.png
Status: CACHED
TTL: 남은 시간 3600초
ETag: "abc123def456"
    ↓
캐시된 파일 즉시 반환
응답 시간: ~50ms
```

```
사용자 요청: GET /api/news.json
    ↓
엣지 서버 캐시 테이블 확인:
Key: /api/news.json
Status: NOT FOUND
    ↓
원본 서버로 요청 전달:
엣지 서버 → 원본 서버
- HTTP 요청 프록시
- 원본 서버에서 콘텐츠 생성/조회
- 응답 데이터 수신
    ↓
엣지 서버에서 처리:
- 사용자에게 콘텐츠 전달
- 캐시 정책에 따라 저장
- TTL 설정 및 메타데이터 기록
응답 시간: ~300ms
```

### 2. 지리적 분산과 지연 시간

#### GeoDNS 동작 방식

```python
# 의사코드로 표현한 GeoDNS 로직
def resolve_cdn_request(user_ip, requested_domain):
    # 1. 사용자 위치 파악
    user_location = geoip_lookup(user_ip)

    # 2. 가용한 엣지 서버 목록 조회
    available_servers = get_healthy_servers()

    # 3. 최적 서버 선택 알고리즘
    best_server = select_optimal_server(
        user_location=user_location,
        servers=available_servers,
        criteria=[
            'geographic_distance',
            'network_latency',
            'server_load',
            'network_capacity'
        ]
    )

    return best_server.ip_address
```

**Anycast 라우팅**

- 동일한 IP 주소를 여러 서버가 공유
- BGP(Border Gateway Protocol)를 통해 최적 경로 선택
- 네트워크 레벨에서 자동으로 가장 가까운 서버로 라우팅

```
동일한 IP (예: 1.1.1.1)를 여러 서버가 공유:

서울 엣지 서버: 1.1.1.1 (AS64512)
도쿄 엣지 서버: 1.1.1.1 (AS64513)
싱가포르 엣지 서버: 1.1.1.1 (AS64514)

BGP 라우팅 테이블에 의해:
- 서울 사용자 → 서울 서버로 자동 라우팅
- 도쿄 사용자 → 도쿄 서버로 자동 라우팅
```

#### 3-Tier 캐싱 모델

```
사용자 요청 → Edge Cache → Regional Cache → Origin Server

Edge Cache (L1):
- 사용자와 가장 가까운 위치
- 가장 인기 있는 콘텐츠 (Hot Data)
- 작은 용량, 빠른 응답
- TTL: 짧음 (1시간~1일)

Regional Cache (L2):
- 여러 Edge Cache를 담당
- 중간 정도 인기 콘텐츠 (Warm Data)
- 중간 용량, 보통 응답 속도
- TTL: 중간 (1일~1주)

Origin Server (L3):
- 모든 콘텐츠의 원본
- 장기 보관 콘텐츠 (Cold Data)
- 대용량, 상대적으로 느린 응답
```

캐시 미스 처리

```
1. L1 캐시 미스 발생
   └→ L2 캐시에서 조회
       ├→ L2 HIT: L1으로 복사 후 사용자에게 전달
       └→ L2 MISS: Origin에서 조회
           └→ L2, L1에 순차적으로 복사 후 전달
```

**RTT (Round Trip Time) 최소화**

```
물리적 거리와 지연 시간의 관계:
서울 → 부산: ~5ms
서울 → 도쿄: ~30ms
서울 → 싱가포르: ~50ms
서울 → 미국 서부: ~150ms
서울 → 미국 동부: ~200ms
```

**레이턴시 최적화 요소**

- 물리적 거리
- 네트워크 홉 수
- 네트워크 혼잡도
- 서버 응답 시간

### 3. 캐싱 알고리즘

**LRU (Least Recently Used)**

```
캐시 공간이 부족할 때:
1. 가장 오랫동안 사용되지 않은 콘텐츠 제거
2. 새로운 콘텐츠 저장
3. 접근 시간 기록 업데이트
```

**LFU (Least Frequently Used)**

```
사용 빈도를 기반으로:
1. 접근 횟수가 가장 적은 콘텐츠 제거
2. 인기 있는 콘텐츠를 더 오래 보관
3. 통계 기반 최적화
```

**TTL (Time To Live) 기반**

```
시간 기반 만료:
1. 각 캐시 항목에 TTL 설정
2. TTL 만료 시 자동 제거
3. 원본 서버에서 최신 버전 확인
```

## 네트워크 성능 최적화 기법

### 1. TCP 최적화

**TCP 연결 재사용**

```
HTTP/1.1: Keep-Alive 연결
- Connection: keep-alive
- 여러 요청을 하나의 TCP 연결로 처리

HTTP/2: 멀티플렉싱
- 하나의 TCP 연결에서 여러 스트림 동시 처리
- 헤더 압축 (HPACK)
- 서버 푸시 기능

Keep-Alive 연결 관리:
클라이언트 연결 풀:
- 최대 동시 연결 수: 100
- 연결 유지 시간: 60초
- 재사용 가능한 연결 우선 사용

Connection Coalescing:
- 동일 서버의 여러 도메인을 하나의 연결로 처리
- HTTP/2 멀티플렉싱 활용
```

**TCP 혼잡 제어**

```
느린 시작 (Slow Start):
1. 초기 윈도우 크기 작게 설정
2. ACK 수신 시마다 윈도우 크기 증가
3. 패킷 손실 시 윈도우 크기 감소
```

### 2. 대역폭 최적화

**압축 기술**

```
콘텐츠 요청 시:

1. Accept-Encoding 헤더 확인
   ↓
2. 지원되는 압축 방식 선택 (br > gzip > deflate)
   ↓
3. 압축된 버전이 캐시에 있는지 확인
   ├→ 있음: 압축된 버전 전송
   └→ 없음: 원본 압축 후 캐시 저장 및 전송
   ↓
4. Content-Encoding 헤더와 함께 응답

Gzip 압축:
- 텍스트 파일 70-90% 크기 감소
- CPU 사용량 vs 대역폭 절약 트레이드오프

Brotli 압축:
- Gzip 대비 20-25% 추가 압축
- 최신 브라우저 지원
```

**콘텐츠 최적화**

```
이미지 최적화:
- JPEG → WebP (25-30% 크기 감소)
- PNG → WebP (50% 크기 감소)
- 적응형 이미지 크기 조정

JavaScript/CSS 최적화:
- 미니피케이션 (공백, 주석 제거)
- 번들링 (여러 파일을 하나로 합치기)
- 트리 셰이킹 (사용하지 않는 코드 제거)
```

## 분산 시스템 관점의 CDN

### 1. 일관성 모델

**Eventual Consistency (최종 일관성)**

```
콘텐츠 업데이트 시:
1. 원본 서버에서 콘텐츠 변경
2. 모든 엣지 서버에 즉시 반영되지 않음
3. 시간이 지나면서 점진적으로 동기화
4. 최종적으로 모든 노드가 일관된 상태
```

**Cache Invalidation (캐시 무효화)**

```
무효화 전략:
1. Push 방식: 원본 서버에서 변경 사항 푸시
2. Pull 방식: 엣지 서버에서 주기적으로 확인
3. 하이브리드: 중요한 변경은 푸시, 일반적인 경우 Pull
```

```
Origin Server에서 콘텐츠 업데이트 시:

1. 업데이트 발생
   ↓
2. 모든 CDN 엣지 서버에 무효화 신호 전송
   ↓
3. 각 엣지 서버에서 해당 캐시 항목 삭제
   ↓
4. 다음 요청 시 Origin에서 새 버전 가져옴

장점: 빠른 동기화
단점: 네트워크 오버헤드, 복잡성
```

```
TTL 기반 자동 만료:

1. 캐시 저장 시 TTL 설정 (예: 1시간)
   ↓
2. TTL 만료까지 캐시 사용
   ↓
3. TTL 만료 후 첫 요청 시:
   - Origin에서 Last-Modified 확인
   - ETag 비교를 통한 변경 감지
   - 변경된 경우만 새 버전 다운로드

장점: 네트워크 효율성
단점: 일시적 불일치 가능
```

### 2. 장애 처리 및 복구

**헬스 체크 시스템**

```
각 엣지 서버에 대한 주기적 검사:

HTTP Health Check:
- 5초마다 GET /health 요청
- 응답 시간 < 100ms, 상태 코드 200 확인
- 연속 3회 실패 시 서버 제외

TCP Health Check:
- 특정 포트(80, 443)에 연결 테스트
- 3초 타임아웃 설정
- 연결 실패 시 즉시 제외

Application Health Check:
- 실제 콘텐츠 요청 및 응답 검증
- 응답 내용의 유효성 확인
```

**Failover 메커니즘**

```
장애 감지 시 처리 흐름:

1. Server1 장애 감지
   ↓
2. DNS에서 Server1 IP 제거
   ↓
3. 새로운 요청을 Server2, Server3으로 분산
   ↓
4. Server1 복구 감지 시 다시 DNS에 추가
   ↓
5. 트래픽 정상 분산 재개

TTL을 짧게 설정하여 빠른 전환 가능 (30초~5분)
```

**Load Balancing (부하 분산)**

```
알고리즘:
1. Round Robin: 순차적 분배
2. Weighted Round Robin: 가중치 기반 분배
3. Least Connections: 연결 수 기반 분배
4. Geographic: 지리적 위치 기반 분배
```

## 보안 및 네트워크 보호

### 1. DDoS 공격 방어

**트래픽 분산**

```
공격 완화 메커니즘:
1. 대용량 트래픽을 여러 서버로 분산
2. 비정상적인 트래픽 패턴 감지
3. 임계값 초과 시 자동 차단
4. 정상 트래픽과 공격 트래픽 구분
```

**Rate Limiting (속도 제한)**

```
제한 정책:
- IP당 초당 요청 수 제한
- 사용자 세션당 제한
- API 엔드포인트별 제한
- 지역별 트래픽 제한
```

### 2. 네트워크 보안

**SSL/TLS 종료**

```
암호화 처리:
1. 엣지 서버에서 SSL/TLS 종료
2. 원본 서버까지 암호화 연결 유지
3. 인증서 관리 및 갱신 자동화
4. 최신 암호화 알고리즘 적용
```

## 성능 측정 및 모니터링

### 1. 핵심 메트릭

**네트워크 성능 지표**

```
TTFB (Time To First Byte):
- DNS 조회 시간
- TCP 연결 시간
- SSL 핸드셰이크 시간
- 서버 응답 시간

캐시 성능 지표:
- 캐시 히트율 (Cache Hit Ratio)
- 캐시 미스율 (Cache Miss Ratio)
- 평균 응답 시간
- 대역폭 사용량
```

### 2. 모니터링 도구

**실시간 모니터링**

```
측정 항목:
- 전 세계 엣지 서버 상태
- 트래픽 분포 및 패턴
- 응답 시간 분포
- 에러율 및 가용성
- 대역폭 사용량
```

## CDN의 네트워크 프로토콜

### 1. HTTP/HTTPS 최적화

**HTTP/2 특성**

```
멀티플렉싱:
- 하나의 TCP 연결에서 여러 요청 동시 처리
- 헤드 오브 라인 블로킹 해결
- 바이너리 프레이밍으로 효율성 향상

서버 푸시:
- 클라이언트 요청 전에 리소스 전송
- 페이지 로딩 시간 단축
- 캐시 효율성 개선
```

**HTTP/3 (QUIC)**

```
주요 개선사항:
- UDP 기반 전송
- 연결 설정 시간 단축
- 패킷 손실에 강인함
- 모바일 네트워크 최적화
```

### 2. 캐싱 프로토콜

**Cache-Control 헤더**

```
캐시 지시어:
- public: 공유 캐시에 저장 가능
- private: 브라우저 캐시에만 저장
- no-cache: 재검증 후 사용
- no-store: 캐시 저장 금지
- max-age: 캐시 유효 시간 설정
```

**ETag (Entity Tag)**

```
캐시 검증:
1. 서버가 콘텐츠에 고유 식별자 부여
2. 클라이언트가 If-None-Match 헤더로 검증
3. 콘텐츠 변경 시에만 전체 다운로드
4. 대역폭 절약 및 응답 시간 단축
```

## 글로벌 네트워크 인프라

### 1. 인터넷 익스체인지 포인트 (IXP)

**직접 피어링**

```
네트워크 경로 최적화:
- ISP 간 직접 연결
- 중간 홉 수 감소
- 지연 시간 최소화
- 대역폭 비용 절감
```

### 2. 해저 케이블과 백본 네트워크

**대륙 간 연결**

```
물리적 인프라:
- 해저 광케이블 네트워크
- 대륙 간 지연 시간 결정
- 네트워크 용량 및 안정성
- 자연 재해 대응 계획
```

### 캐싱 전략

typescript

```typescript
// Cache-Control 헤더 예시
const cacheHeaders = {
  // 정적 자산 - 1년 캐싱
  'Cache-Control': 'public, max-age=31536000, immutable',

  // API 응답 - 5분 캐싱
  'Cache-Control': 'public, max-age=300, s-maxage=300',

  // 동적 콘텐츠 - 캐싱 안함
  'Cache-Control': 'no-cache, no-store, must-revalidate',
};
```

## CDN의 핵심 이점

### 1. 성능 향상

- **지연 시간 감소**: 물리적으로 가까운 서버에서 콘텐츠 제공
- **로딩 속도 개선**: 대용량 파일(이미지, 비디오, CSS, JS)의 빠른 전송
- **대역폭 효율성**: 원본 서버 부하 분산

### 2. 가용성 및 안정성

- **서버 장애 대응**: 한 서버가 다운되어도 다른 서버에서 서비스 제공
- **트래픽 분산**: 갑작스러운 트래픽 증가에도 안정적인 서비스
- **DDoS 공격 완화**: 분산된 네트워크로 공격 흡수

### 3. 비용 효율성

- **대역폭 비용 절감**: 원본 서버의 대역폭 사용량 감소
- **인프라 비용 절감**: 글로벌 서버 구축 없이 전 세계 서비스 가능

| **대표 질문**                    | **답변 키워드 & 팁**                                                                                                                                  |
| -------------------------------- | ----------------------------------------------------------------------------------------------------------------------------------------------------- |
| **CDN이란? 왜 쓰나요?**          | “지리적으로 분산된 엣지 서버가 정적 자산을 캐싱하여 RTT를 최소화하고, 원 서버 부하와 대역폭 비용을 줄입니다.” → 속도·부하·보안 3가지를 꼭 동시에 언급 |
| **CDN과 캐싱의 관계?**           | “CDN 엣지는 _프록시 캐시_ 역할을 하며 Cache-Control, ETag, s-maxage 등 HTTP 헤더를 해석해 캐시 만료·검증을 자동 수행합니다.”                          |
| **수정한 JS가 바로 안 보일 때?** | ① **파일 버전링**: main.abc123.js② **Purge API**: 특정 패스나 태그만 무효화③ **짧은 TTL + SWR** 전략 설명                                             |
| **HTTPS 트래픽 흐름?**           | “TLS 핸드셰이크는 엣지 서버에서 종료(TLS termination)돼, 백엔드까지는 HTTP 혹은 재-TLS로 전달합니다. 따라서 SSL 인증서는 CDN이 관리합니다.”           |
| **TCP vs UDP 전송?**             | 대부분 HTTP/2는 TCP 위, HTTP/3(QUIC)는 UDP 위 → ‘헤드-오브-라인 블로킹’ 해결 의도까지 설명하면 가점                                                   |
| **DDoS 방어?**                   | 엣지 레벨에서 레이트 리밋·IP reputation 필터 → 원 서버 도달 이전에 차단                                                                               |
