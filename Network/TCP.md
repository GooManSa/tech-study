## 📌 TCP란?

TCP(Transmission Control Protocol)는 애플리케이션 간에 안전하고 신뢰성 있는 데이터 통신을 가능하게 하는 프로토콜입니다.
기본적으로 신뢰성이 없는(Unreliable) 네트워크 환경에서 신뢰할 수 있는(Reliable) 전송을 보장하도록 설계되었습니다.

<br>

## ✅ TCP의 특징

- **신뢰성 있는 데이터 전송**
- **연결형 서비스**
- **흐름제어, 혼잡제어**
- **ARQ**

<br>

## 🔁 TCP 통신과정

### 📦 TCP 패킷 생성 과정

1. 애플리케이션으로부터 전달받은 데이터를 일정 단위로 분할
2. 분할한 데이터에 TCP 헤더를 붙여서 **TCP 세그먼트**를 생성합
3. TCP 세그먼트를 IP 데이터그램으로 변환
4. IP 데이터그램을 네트워크를 통해 수신 측 애플리케이션에 전달
   ※ IP 데이터그램: 인터넷 통신에서 사용되는 데이터 전송 단위

<br>

### 📑 TCP 세그먼트 구조
TCP 세그먼트는 **헤더(Header)**와 **데이터(Data)** 영역으로 나뉘며, 헤더에는 통신을 위한 필수 정보들이 포함되어 있습니다.

<img width="736" alt="스크린샷 2025-06-29 오후 5 09 02" src="https://github.com/user-attachments/assets/3a52f35b-09a8-44e3-aac0-6be3aa64acdf" />


주요 헤더 필드를 자세히 살펴보면..
- **Source Port / Destination Port**: 송신자 및 수신자의 포트 번호
- **Sequence Number (SYN)**: 데이터 순서를 나타내는 번호
- **Acknowledgment Number (ACK)**: 다음으로 기대되는 시퀀스 번호
- **Data Offset**: TCP 헤더의 크기 (최소 20바이트, 최대 60바이트)
- **Control Bits (Flags)**: SYN, ACK, FIN 등 제어용 플래그
- **Window Size**: 송신자가 수신자로부터 받을 수 있는 최대 데이터 양
- **Checksum**: 데이터 전송 중 오류 검출

<br>

통신 과정에서 분할된 데이터가 순서대로 전달되지 않거나 각자 다른 경로로 통신될 수 있는데, 위와 같은 TCP 헤더가 있어 수신 애플리케이션에서 데이터를 안전하고 정확하게 원상복구할 수 있습니다.



<br>

## 🤝 TCP Handshake

TCP 통신을 하기 위해서는 네트워트 연결 설정이 필요합니다. 데이터를 발송하는 애플리케이션과 수신하는 애플리케이션 모두가 준비가 됐다는 것을 보장하기 위해 필요합니다.
이 과정으로 이뤄지는 작업이 **3-Way-Handshack**와 **4-Way-Handshake**입니다.

<br>

### 🔌 **3-Way-Handshake**
<img width="720" alt="스크린샷 2025-06-29 오후 5 09 29" src="https://github.com/user-attachments/assets/ec934517-1a6d-4b42-af33-10b900d318b8" />

**[ 연결 과정 ]**

총 3단계로 연결을 설정하며, SYN과 ACK 플래그를 사용합니다. 각각의 단계에서 수행 내역은 다음과 같습니다.

1. **SYN** : 클라이언트 → 서버에 연결 요청 (ISN 포함)
2. **SYN + ACK** : 서버 → 클라이언트에 수락 및 서버 ISN 전송
3. **ACK** : 클라이언트 → 서버에 응답

Handshake 과정에서 클라이언트와 서버는 시퀀스 번호를 설정하고, 윈도우 크기를 협상해 데이터 흐름을 제어하기 때문에 신뢰성 있는 데이터 전송이 가능합니다. 또한 패킷 손실이 발생해도 재전송 메커니즘을 통해 데이터를 정확하게 전달할 수 있습니다.

<br>

### 🔌 **4-Way-Handshake**
<img width="688" alt="스크린샷 2025-06-29 오후 5 09 58" src="https://github.com/user-attachments/assets/0311a39a-f667-48f1-9b4d-deadffb8a0da" />

**[ 연결해제 과정 ]**

총 4단계로 연결을 해제하며, FIN과 ACK 플래그를 사용합니다. 각각의 단계에서 수행 내역은 다음과 같습니다.

1. 클라이언트 → 서버에 FIN 요청 (연결 종료 요청)
2. 서버 → 클라이언트에 ACK 응답
3. 서버 → 클라이언트에 FIN 요청
4. 클라이언트 → 서버에 ACK 응답 후 일정 시간 TIME_WAIT 상태 유지

<br>

### ❓ 클라이언트가 왜 **TIME_WAIT** 상태를 유지하는 가.
1. **지연 패킷 수신 대비**
   ⇒ 패킷이 뒤늦게 도달하고 이를 처리하지 못한다면 데이터 무결성 문제가 발생할 수 있음!
2. **재연결 시 상태 충돌 방지**
   ⇒ 만약 LAST_ACK 상태에서 닫히게 되면 다시 새로운 연결을 하려고 할 때, 해당 장치는 줄곧 LAST_ACK로 되어 있기 때문에 접속 오류가 발생할 수 있음!

<br>

> **💡 용어 참고**
>
> - **SYN** : SYNchronization의 약자, 연결 요청 플래그 <br>
> - **ACK** : ACKnowledgement의 약자, 응답 플래그 <br>
> - **ISN** : Initial Sequence Numbers의 약자, 초기 네트워크 연결을 할 때 할당된 32비트 고유 시퀀스 번호 <br>
> - **TIME_WAIT** : 소켓이 바로 소멸되지 않고 일정 시간 유지되는 상태 <br>
    >	      CentOS6, 우분투에는 60초, 윈도우는 4분으로 설정되어 있다.(OS마다 조금씩 다름)
>

<br>

## 🚦 TCP 흐름제어(Flow Control)

서버(수신) 측이 클라이언트(송신) 측보다 데이터 처리 속도가 빠르면 문제없지만, 서버 측 속도가 빠를 경우 문제가 생길 수 있습니다.

서버 측에서 제한된 저장 용량을 초과한 이후에 도착하는 데이터는 손실 될 수 있으며, 만약 손실 된다면 불필요하게 응답과 데이터 전송이 송/수신 측 간에 빈번히 발생할 수 있다. 이러한 위험을 줄이기 위해 클라이언트 측의 데이터 전송량을 서버 측에 따라 조절해야 합니다.

<br>


### 📍 Sliding Window(Go-Back-N ARQ)

서버 측에서 설정한 윈도우크기만큼 클라이언트 측 확인응답없이 세그먼트를 전송할 수 있게 하여 데이터 흐름을 동적으로 조절하는 제어기법을 말합니다.

 <img width="622" alt="스크린샷 2025-06-29 오후 5 10 19" src="https://github.com/user-attachments/assets/5a7577c3-1683-433e-bf8b-6fd553af3844" />

- 수신 측에서 설정한 윈도우 크기만큼 송신 측이 확인 응답 없이 데이터를 전송
- 수신 측으로부터 ACK를 받으면 윈도우가 이동(slide) 하며 다음 데이터 전송 가능

> 각 측은 송/수신을 위한 별도의 윈도우를 가지며, 수신 측 윈도우가 흐름 제어 기준이 됩니다.

<br>


**[윈도우 슬라이딩 과정]**

TCP/IP 를 사용하는 모든 호스트들은 송신 그리고 수신을 위한 2개의 Window 를 가지고 있다.
Window의 크기는 받는쪽에서 보낸 window size를 보내는 window size로 설정합니다.

<br>

1. **서버(송신) 버퍼**

<img width="556" alt="스크린샷 2025-06-29 오후 5 10 48" src="https://github.com/user-attachments/assets/8bd28a65-b300-4225-874f-98abf4361c24" />

- 200 이전 바이트 모두 보낸 상태
- 200~202 보냈으나 아직 응답 받지 못함
- 203~ 아직 보내지 않은 상태


<br>

2. **클라이언트(수신) 윈도우/ 서버(송신) 윈도우**
    - 클라이언트 윈도우
      <img width="542" alt="스크린샷 2025-06-29 오후 5 15 45" src="https://github.com/user-attachments/assets/8efc5839-149a-411c-9be7-fa7f473f5728" />

    - 서버 윈도우 - 윈도우 사이즈 결정
        - 클라이언트 윈도우보다 작거나 같은 크기로 지정하게되면 흐름제어가 가능하다.
          <img width="536" alt="스크린샷 2025-06-29 오후 5 15 56" src="https://github.com/user-attachments/assets/92c31dff-eb5f-44cf-a8f6-0f88a66e3171" />
          <br>

3. **서버 원도우 이동**

   <img width="546" alt="스크린샷 2025-06-29 오후 5 19 35" src="https://github.com/user-attachments/assets/9b953a9f-358f-4aeb-b629-75f24012c845" />

    - **Before** : 203 ~ 204를 전송하면 클라이언트 측 확인 응답 203을 보내고, 서버 측은 이를 받아 after 상태와 같이 클라이언트 윈도우를 203 ~ 209 범위로 이동
    - **after** : 205 ~ 209가 전송 가능한 상태

<br>


## 🚨 **에러 제어 : ARQ(Automatic repeat request)**

패킷 손실, 중복, 순서 변경 등을 감지하고 재전송을 요청하는 방식입니다. 체크섬, 시퀀스 넘버, 타임아웃 등의 메커니즘을 활용합니다.

### 🔁 ARQ 방식 종류
### 📌 Stop-and-Wait

- 하나씩 전송하고 ACK를 받은 뒤 다음 패킷 전송
- 윈도우 사이즈가 1인 방식
  ※ 비효율적이며 TCP에서 사용하지 않음
  <img width="640" alt="스크린샷 2025-06-29 오후 5 21 50" src="https://github.com/user-attachments/assets/24887fd2-147c-453c-a8b6-64d90dcb5372" />

<br>

### 📌 Go-Back-N

- 윈도우 크기만큼 패킷 전송
- 에러 발생 시 문제 패킷부터 모두 재전송
- 윈도우 사이즈가 2 이상
  <img width="668" alt="스크린샷 2025-06-29 오후 5 22 08" src="https://github.com/user-attachments/assets/87e7a35e-30ac-4ea5-bad4-a4a667e4d91f" />

<br>

### 📌 Selective Repeat

- 에러 발생 패킷에 대해서만 재전송을 요구해 재조립하는 방식입니다.
- 타임아웃 이전에 도착한 패킷은 버퍼에 저장하고, 타임아웃 후 재전송을 하여 받은 패킷을 버퍼의 상위로 올려 조립합니다.

<img width="682" alt="스크린샷 2025-06-29 오후 5 22 28" src="https://github.com/user-attachments/assets/0fa24930-13cc-4dd7-923d-d4c4974679b0" />

<br>

## 🌐 TCP 혼잡 제어(Congestion Control)

혼잡제어는 흐름제어와 비슷하게 전송하는 패킷의 갯수를 제어하지만, 네트워크 자원 부족이나 대역폭 초과로 인해 발생하는 혼잡 상태를 제어하기 위한 메커니즘입니다.

<img width="648" alt="스크린샷 2025-06-29 오후 5 22 44" src="https://github.com/user-attachments/assets/ebefab9b-6700-4e2b-b3ce-69f3e4b1fddd" />

※ SSTresh(Slow Start Treshhold) : Slow Start 임계점

TCP는 네트워크에서 발생할 수 있는 혼잡을 효과적으로 제어하기 위해 다양한 알고리즘을 사용합니다.

<br>

### 📈 주요 혼잡 제어 알고리즘

### ✅ AIMD (Additive Increse / Multicative Decrease)

- 정상 전송 시 윈도우 크기 1씩 증가
- 혼잡 발생 시 윈도우 크기를 절반으로 감소
  ⇒ 이 방식은 안정성을 중시하기 때문에 신뢰성 있는 데이터 전송이 가능하지만, 네트워크의 최대 대역폭을 활용하기까지 시간이 오래 걸린다는 단점이 있다!

<br>

### ✅ Slow Start (느린 시작)
- 시작은 윈도우 1로 시작
- 이후 2, 4, 8처럼 기하급수적으로 증가
- 혼잡 발생 시 윈도우를 다시 1로 초기화
  ⇒ 초기에는 네트워크의 수용량을 알 수 없기 때문에 빠르게 수용 한계에 도달하려는 전략이며, 혼잡이 감지되면 이후부터는 보다 보수적인 방식으로 전환

<br>

### ✅ Fast Retransmit (빠른 재전송)
- TCP의 혼잡 조절에 추가된 정책
- 동일한 ACK 번호가 3번 이상 반복되면
  → 해당 패킷이 손실된 것으로 판단하고 즉시 재전송

<br>

### ✅ Fast Recovery(빠른 회복)
- 혼잡 발생 시 윈도우 크기를 1로 줄이지 않고
  → 절반 수준으로 감소
  → 이후에는 선형적으로 증가하며 회복

<br>


## 📚 추가
### 1️⃣ 흐름제어 & 혼잡제어
1. **TCP 흐름제어 (Flow Control)**

   **🕒 언제 사용하는가?**
    - 수신자의 처리 속도보다 송신자가 데이터를 더 빨리 보낼 때
    - 수신자의 버퍼가 가득 차거나 부족할 우려가 있을 때

   **🎯 왜 필요한가?**
    - 수신자가 데이터를 처리하지 못하면 버퍼 오버플로우 발생 가능
    - 이를 막기 위해 수신자는 현재 가능한 버퍼 크기(Receiver Window)를 송신자에게 알려줌 <br><br>

   > 즉, 수신자의 능력에 맞게 송신을 조절하기 위해 사용

2. **TCP 혼잡제어(Congestion Control)**

   **🕒 언제 사용하는가?**
    - 네트워크 중간(라우터, 스위치 등)이 과부하 상태일 때
    - 패킷 손실이나 RTT 증가 등의 혼잡 징후가 나타날 때

   **🎯 왜 필요한가?**
    - 너무 많은 패킷이 네트워크에 몰리면 라우터의 큐가 넘쳐서 패킷이 손실됨
    - 이를 방지하기 위해 송신자는 네트워크 상태를 보고 전송 속도를 조절 <br><br>

   > 즉, 네트워크 자체가 버티는 수준에 맞게 송신을 조절하기 위해 사용

<br>

### 2️⃣ TCP에서 네트워크 혼잡 감지 기술
1. **패킷 손실 (Packet Loss) 감지**

    - **타임 아웃(Timeout)**
        - ACK(응답)가 일정 시간 내 도착하지 않으면 타임아웃 발생 → 혼잡으로 판단

    - **중복 ACK(Duplicate ACKs)**
        - 같은 ACK가 3번 연속 수신되면, 그 패킷 다음의 패킷이 손실되었음을 의미

2. **지연 시간 증가 (RTT 증가)**
    - RTT(Round Trip Time)가 점점 증가하면 네트워크에 병목이 생기고 있다고 판단
    - 혼잡 제어 알고리즘 중 일부는 RTT 기반으로 혼잡을 예측함


<br>

### 3️⃣ 혼잡 감지를 이용한 TCP 알고리즘
| 알고리즘     | 감지 방식              | 특징                                                         |
|--------------|------------------------|--------------------------------------------------------------|
| TCP Reno     | 중복 ACK / 타임아웃     | 전통적인 방식, 빠른 재전송과 혼잡 회피 알고리즘 사용           |
| TCP NewReno  | 중복 ACK, 빠른 복구     | Reno 개선 버전, 손실된 여러 패킷을 더 효과적으로 복구 가능     |
| TCP Vegas    | RTT 기반               | 지연 증가를 통해 혼잡을 예측, 패킷 손실 발생 전 감지 가능       |
| TCP BBR      | 대역폭-지연 기반        | Google 개발, 실제 대역폭과 지연을 측정해 전송속도 최적화       |

<br>

### 4️⃣ TCP vs UDP가 등장하게 된 배경
1. IP 프로토콜의 한계
    - IP는 단순히 장치 간 전송만 담당함
    - 하나의 장치에서 여러 애플리케이션 간 통신은 불가능 → 포트 개념 도입

2. IP의 오류 대응 부족
    - 오류 알림은 ICMP가 하지만, 복구는 불가능
    - 오류 복구를 위한 프로토콜 필요 → TCP/UDP 등장

<br>

### 5️⃣ TCP vs UDP의 오류 처리 차이점
| 항목       | TCP                                | UDP                                |
|---------------|------------------------------------|------------------------------------|
| 신뢰성        | 보장 (순서, 중복 제거, 재전송 등)     | 보장하지 않음                         |
| 연결 방식     | 연결 지향형                           | 비연결형                             |
| 에러 처리     | 자동 복구(ARQ 등)                    | 애플리케이션이 직접 처리해야 함         |
| 사용 예시     | 웹, 이메일, 파일 전송 등               | 스트리밍, VoIP, 게임 등               |

<br>
<br>

> 🔗 참고 <br>
https://docs.tosspayments.com/resources/glossary/tcp <br>
[https://developer111.tistory.com/entry/TCP를-이용한-통신-과정](https://developer111.tistory.com/entry/TCP%EB%A5%BC-%EC%9D%B4%EC%9A%A9%ED%95%9C-%ED%86%B5%EC%8B%A0-%EA%B3%BC%EC%A0%95)
>
